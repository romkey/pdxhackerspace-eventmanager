#!/usr/bin/env bash
#
# Run the same tests that GitHub CI runs, locally using Docker
#
# Usage:
#   bin/test-ci           # Run all tests (lint, specs, security)
#   bin/test-ci lint      # Run only linting
#   bin/test-ci specs     # Run only RSpec tests
#   bin/test-ci security  # Run only security checks
#   bin/test-ci quick     # Run lint + specs (skip security)
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

COMPOSE_FILE="docker-compose.dev.yml"
WEB_CONTAINER="eventmanager_web"

# Check if docker compose is available
if command -v docker-compose &> /dev/null; then
    COMPOSE_CMD="docker-compose"
elif docker compose version &> /dev/null; then
    COMPOSE_CMD="docker compose"
else
    echo -e "${RED}Error: docker compose is not installed${NC}"
    exit 1
fi

# Helper functions
print_header() {
    echo ""
    echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Ensure containers are running
ensure_containers() {
    print_header "Ensuring Docker containers are running"
    
    if ! $COMPOSE_CMD -f $COMPOSE_FILE ps --services --filter "status=running" | grep -q "web"; then
        echo "Starting containers..."
        $COMPOSE_CMD -f $COMPOSE_FILE up -d db redis web
        echo "Waiting for services to be healthy..."
        sleep 5
    else
        print_success "Containers are already running"
    fi
}

# Run linting
run_lint() {
    print_header "Running RuboCop Linting"
    
    if $COMPOSE_CMD -f $COMPOSE_FILE exec -T web bundle exec rubocop --parallel; then
        print_success "Linting passed"
        return 0
    else
        print_error "Linting failed"
        return 1
    fi
}

# Setup test database
setup_test_db() {
    print_header "Setting up test database"
    
    $COMPOSE_CMD -f $COMPOSE_FILE exec -T -e RAILS_ENV=test web bash -c "
        bundle exec rails db:create 2>/dev/null || true
        bundle exec rails db:schema:load
    "
    print_success "Test database ready"
}

# Run RSpec tests
run_specs() {
    print_header "Running RSpec Tests"
    
    # Setup test database first
    setup_test_db
    
    # Build assets for feature specs
    echo "Building assets..."
    $COMPOSE_CMD -f $COMPOSE_FILE exec -T -e RAILS_ENV=test web bash -c "
        yarn build 2>/dev/null || true
        yarn build:css 2>/dev/null || true
    "
    
    echo "Running tests..."
    if $COMPOSE_CMD -f $COMPOSE_FILE exec -T -e RAILS_ENV=test -e DISABLE_SPRING=1 web \
        bundle exec parallel_rspec spec/ -n 2 --verbose; then
        print_success "All tests passed"
        return 0
    else
        print_error "Some tests failed"
        return 1
    fi
}

# Run specs sequentially (useful for debugging)
run_specs_sequential() {
    print_header "Running RSpec Tests (Sequential)"
    
    setup_test_db
    
    if $COMPOSE_CMD -f $COMPOSE_FILE exec -T -e RAILS_ENV=test -e DISABLE_SPRING=1 web \
        bundle exec rspec --format documentation; then
        print_success "All tests passed"
        return 0
    else
        print_error "Some tests failed"
        return 1
    fi
}

# Run security checks
run_security() {
    print_header "Running Security Checks"
    
    local failed=0
    
    echo "Running bundler-audit..."
    if $COMPOSE_CMD -f $COMPOSE_FILE exec -T web bash -c "
        gem install bundler-audit --no-document 2>/dev/null
        bundle audit check --update
    "; then
        print_success "bundler-audit passed"
    else
        print_warning "bundler-audit found vulnerabilities"
        failed=1
    fi
    
    echo ""
    echo "Running brakeman..."
    if $COMPOSE_CMD -f $COMPOSE_FILE exec -T web bash -c "
        gem install brakeman --no-document 2>/dev/null
        brakeman --no-pager --format plain
    "; then
        print_success "brakeman passed"
    else
        print_warning "brakeman found potential issues"
        # Don't fail on brakeman warnings (matches CI behavior)
    fi
    
    return $failed
}

# Run all tests
run_all() {
    local exit_code=0
    
    ensure_containers
    
    run_lint || exit_code=1
    run_specs || exit_code=1
    run_security || exit_code=1
    
    echo ""
    if [ $exit_code -eq 0 ]; then
        print_header "All CI checks passed! ✓"
    else
        print_header "Some CI checks failed ✗"
    fi
    
    return $exit_code
}

# Run quick tests (lint + specs, no security)
run_quick() {
    local exit_code=0
    
    ensure_containers
    
    run_lint || exit_code=1
    run_specs || exit_code=1
    
    echo ""
    if [ $exit_code -eq 0 ]; then
        print_header "Quick tests passed! ✓"
    else
        print_header "Quick tests failed ✗"
    fi
    
    return $exit_code
}

# Show usage
show_usage() {
    echo "Usage: bin/test-ci [command]"
    echo ""
    echo "Commands:"
    echo "  (none)     Run all tests (lint, specs, security)"
    echo "  lint       Run only RuboCop linting"
    echo "  specs      Run only RSpec tests (parallel)"
    echo "  specs-seq  Run RSpec tests sequentially (for debugging)"
    echo "  security   Run only security checks (bundler-audit, brakeman)"
    echo "  quick      Run lint + specs (skip security)"
    echo "  help       Show this help message"
    echo ""
    echo "Examples:"
    echo "  bin/test-ci              # Full CI suite"
    echo "  bin/test-ci quick        # Fast feedback loop"
    echo "  bin/test-ci specs-seq    # Debug failing tests"
}

# Main
case "${1:-all}" in
    lint)
        ensure_containers
        run_lint
        ;;
    specs)
        ensure_containers
        run_specs
        ;;
    specs-seq)
        ensure_containers
        run_specs_sequential
        ;;
    security)
        ensure_containers
        run_security
        ;;
    quick)
        run_quick
        ;;
    all)
        run_all
        ;;
    help|--help|-h)
        show_usage
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        echo ""
        show_usage
        exit 1
        ;;
esac

